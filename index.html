<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gradient Descent</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<style>
body {
    display: grid;
    grid-template-columns: 1fr 1fr;  /* two columns */
    grid-template-rows: 1fr 1fr;     /* two rows */
    gap: 20px;
    height: 100vh;
    margin: 0;
    padding: 20px;
    box-sizing: border-box;
}

.plot {
    width: 100%;
    height: 100%;
}

/* Optional: make the function + controls container smaller to fit nicely */
#functionWrapper {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
}
#leftSide { flex: 4; display: flex; flex-direction: column; }
#function2D { flex: 1; width: 100%; }
#controls { margin-top: 10px; }
#rightSide { flex: 0.8; display: flex; flex-direction: column; margin-left: 15px; }
button { margin: 5px 0; padding: 6px 12px; border-radius: 8px; border: none; background: #0077cc; color: white; cursor: pointer; }
button:hover { background: #005fa3; }
#tableWrapper { flex: 1; overflow-y: auto; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; }
table { border-collapse: collapse; width: 100%; }
th, td { border: 1px solid #ddd; padding: 6px 10px; text-align: center; }
th { background: #f0f0f0; position: sticky; top: 0; }
</style>
</head>
<body>

<!-- (1,1) 2D graph -->
<div id="function2DWrapper" class="plot" style="grid-column: 1; grid-row: 1; display:flex; flex-direction:column;">
  <div id="equationDisplay" style="text-align:center; font-size:18px; margin-bottom:5px;"></div>
  <div id="function2D" style="flex:1;"></div>
  <div id="controls" style="margin-top:10px; text-align:center;">
    <button id="randomBtn">Generate Random Points</button>
    <button id="stepBtn">+Step</button>
    <button id="step40Btn">+40 Steps</button>
  </div>
</div>

<!-- (1,2) Vector field -->
<div id="gradVectorField" class="plot" style="grid-column: 2; grid-row: 1;"></div>

<!-- (2,1) Table -->
<div id="tableWrapper" class="plot" style="grid-column: 1; grid-row: 2; overflow-y:auto; border:1px solid #ccc; border-radius:8px;">
  <table id="pointsTable">
    <thead>
      <tr><th>#</th><th>x</th><th>y</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<!-- (2,2) SSE graph -->
<div id="surfacePlot" class="plot" style="grid-column: 2; grid-row: 2;"></div>


<script>
const forms = ["A*B^x","A*x^B","A*log(x)+B"];
const chosen = forms[Math.floor(Math.random()*forms.length)];
const A0 = parseFloat((Math.random()*3+1).toFixed(2));
const B0 = parseFloat((Math.random()*3+1).toFixed(2));

let g, dfda, dfdb;
if(chosen==="A*B^x"){
    g=(a,b,x)=>a*Math.pow(b,x);
    dfda=(a,b,x)=>Math.pow(b,x);
    dfdb=(a,b,x)=>a*x*Math.pow(b,x-1);
} else if(chosen==="A*x^B"){
    g=(a,b,x)=>a*Math.pow(x,b);
    dfda=(a,b,x)=>Math.pow(x,b);
    dfdb=(a,b,x)=>a*Math.pow(x,b)*Math.log(x);
} else {
    g=(a,b,x)=>a*Math.log(x)+b;
    dfda=(a,b,x)=>Math.log(x);
    dfdb=(a,b,x)=>1;
}

const xStart = chosen.includes("log(x)")?1:0;
const xEnd = 10;
const nPoints=10;
let dataset=[];
function generatePoints(){
    dataset=[];
    const scale=0.05, minError=0.1;
    for(let i=0;i<nPoints;i++){
        const x = Math.random()*(xEnd-xStart)+xStart;
        const trueY = g(A0,B0,x);
        const errMag = Math.max(scale*Math.abs(trueY),minError);
        const y = trueY + (Math.random()-0.5)*2*errMag;
        dataset.push({x,y});
    }
}
generatePoints();

const xLine=[];
for(let x=xStart;x<=xEnd;x+=0.1) xLine.push(x);
const yLine = xLine.map(x=>g(A0,B0,x));

const funcTrace={type:"scatter",mode:"lines",x:xLine,y:yLine,line:{color:"red"},visible:false};
const pointsTrace={type:"scatter",mode:"markers",x:dataset.map(p=>p.x),y:dataset.map(p=>p.y),marker:{color:"black",size:8}};

const layout2D={dragmode:false,xaxis:{range:[0,10]},yaxis:{range:[Math.min(...dataset.map(p=>p.y))-1,Math.max(...dataset.map(p=>p.y))+1]}};
Plotly.newPlot("function2D",[funcTrace,pointsTrace],layout2D);

function updateTable(){
    const tbody=document.querySelector("#pointsTable tbody");
    tbody.innerHTML="";
    dataset.forEach((p,i)=>{
        const row=document.createElement("tr");
        row.innerHTML=`<td>${i+1}</td><td>${p.x.toFixed(3)}</td><td>${p.y.toFixed(3)}</td>`;
        tbody.appendChild(row);
    });
}
updateTable();

// --- SSE surface ---
const aVals=math.range(0.5,5,0.2).toArray();
const bVals=math.range(0.5,5,0.2).toArray();

function computeSSE(a,b){
    let sse=0;
    dataset.forEach(p=>{
        const fx=g(a,b,p.x);
        sse+=Math.pow(fx-p.y,2);
    });
    return sse;
}

function plotSSE(){
    const surfaceZ=[];
    for(let i=0;i<aVals.length;i++){
        const row=[];
        for(let j=0;j<bVals.length;j++){
            row.push(computeSSE(aVals[i],bVals[j]));
        }
        surfaceZ.push(row);
    }
    Plotly.newPlot("surfacePlot",[{
        type:"surface",x:aVals,y:bVals,z:surfaceZ,colorscale:"Viridis",opacity:0.9
    }],{scene:{xaxis:{title:"a"},yaxis:{title:"b"},zaxis:{title:"SSE"}}});
}

// --- Gradient field ---
function plotGradientField() {
    let arrowTraces = [];
    const step = 0.15; // shorter arrows

    function clip(value, min = 0, max = 5) {
        return Math.max(min, Math.min(max, value));
    }

    // Compute magnitudes for color scaling
    let magnitudes = [];
    for (let i = 0; i < aVals.length; i++) {
        for (let j = 0; j < bVals.length; j++) {
            let dSda = 0, dSdb = 0;
            dataset.forEach(p => {
                const fx = g(aVals[i], bVals[j], p.x);
                dSda += 2 * (fx - p.y) * dfda(aVals[i], bVals[j], p.x);
                dSdb += 2 * (fx - p.y) * dfdb(aVals[i], bVals[j], p.x);
            });
            magnitudes.push(Math.sqrt(dSda*dSda + dSdb*dSdb));
        }
    }

    const minMag = Math.min(...magnitudes);
    const maxMag = Math.max(...magnitudes);

    let k = 0;
    for (let i = 0; i < aVals.length; i++) {
        for (let j = 0; j < bVals.length; j++) {
            let dSda = 0, dSdb = 0;
            dataset.forEach(p => {
                const fx = g(aVals[i], bVals[j], p.x);
                dSda += 2 * (fx - p.y) * dfda(aVals[i], bVals[j], p.x);
                dSdb += 2 * (fx - p.y) * dfdb(aVals[i], bVals[j], p.x);
            });

            const norm = Math.sqrt(dSda*dSda + dSdb*dSdb);
            if (norm === 0) { k++; continue; }

            const u = -dSda / norm * step;
            const v = -dSdb / norm * step;

            let ratio = (magnitudes[k] - minMag) / (maxMag - minMag + 1e-9);
            ratio = Math.sqrt(ratio);
            const color = `rgb(${Math.round(255*ratio)},0,${Math.round(255*(1-ratio))})`;

            arrowTraces.push({
                type: "scatter",
                mode: "lines",
                x: [clip(aVals[i]), clip(aVals[i]+u)],
                y: [clip(bVals[j]), clip(bVals[j]+v)],
                line: { color: color, width: 2 },
                showlegend: false
            });

            // Arrowhead
            const headSize = 0.05;
            const angle = Math.atan2(v, u);
            const left = angle + Math.PI * 0.25;
            const right = angle - Math.PI * 0.25;

            const xHead = [
                clip(aVals[i]+u),
                clip(aVals[i]+u - headSize*Math.cos(left)),
                clip(aVals[i]+u - headSize*Math.cos(right))
            ];
            const yHead = [
                clip(bVals[j]+v),
                clip(bVals[j]+v - headSize*Math.sin(left)),
                clip(bVals[j]+v - headSize*Math.sin(right))
            ];

            arrowTraces.push({
                type: "scatter",
                mode: "lines",
                x: [xHead[0], xHead[1], null, xHead[0], xHead[2]],
                y: [yHead[0], yHead[1], null, yHead[0], yHead[2]],
                line: { color: color, width: 2 },
                showlegend: false
            });

            k++;
        }
    }

    // Gradient descent trail
    const trailTrace = {
        type: "scatter",
        mode: "lines+markers",
        x: trailX.map(v => clip(v)),
        y: trailY.map(v => clip(v)),
        line: { color: "red", width: 3 },
        marker: { size: 5, color: "red" },
        showlegend: false
    };

    // Current GD point
    const currentPointTrace = {
        type: "scatter",
        mode: "markers",
        x: [clip(gdPoint.a)],
        y: [clip(gdPoint.b)],
        marker: { size: 10, color: "black", symbol: "x" },
        showlegend: false
    };

    // Plot all together with fixed axis ranges
    Plotly.newPlot("gradVectorField", [...arrowTraces, trailTrace, currentPointTrace], {
        xaxis: { range: [0, 5], autorange: false, title: "a", scaleanchor: "y", scaleratio: 1},
        yaxis: { range: [0, 5], autorange: false, title: "b" },
        showlegend: false
    });
}



// --- Gradient Descent point with trail ---
let gdPoint={a:Math.random()*4+0.5,b:Math.random()*4+0.5};
let trailX=[gdPoint.a], trailY=[gdPoint.b], trailZ=[computeSSE(gdPoint.a,gdPoint.b)];

function plotGDPoint() {
    // --- Prepare surface Z with log scale ---
    const surfaceZ = aVals.map((a, i) => 
        bVals.map((b, j) => Math.log10(computeSSE(a, b) + 1e-6))
    );

    // Compute dynamic z-axis ticks for actual SSE
    const allZ = surfaceZ.flat();
    const minZ = Math.floor(Math.min(...allZ));
    const maxZ = Math.ceil(Math.max(...allZ));
    const nTicks = 5;

    const tickvals = Array.from({length: nTicks}, (_, i) => minZ + i*(maxZ - minZ)/(nTicks-1));
    const ticktext = tickvals.map(v => (10**v).toFixed(0));

    // Surface trace
    const surfaceTrace = {
        type: "surface",
        x: aVals,
        y: bVals,
        z: surfaceZ,
        colorscale: "Viridis",
        opacity: 0.9,
        colorbar: { title: "log10(SSE)" }
    };

    // Gradient descent trail Z: compute log10(SSE) for each point
    const gdZ = trailX.map((a, i) => Math.log10(computeSSE(a, trailY[i]) + 1e-6));

    const gdTrace = {
        type: "scatter3d",
        mode: "lines+markers",
        x: trailX.map(a => Math.max(0, Math.min(5, a))),  // clip to [0,5]
        y: trailY.map(b => Math.max(0, Math.min(5, b))),
        z: gdZ,
        marker: { size: 5, color: "red", symbol: "circle" },
        line: { color: "red", width: 3 }
    };

    Plotly.react("surfacePlot", [surfaceTrace, gdTrace], {
        scene: {
            xaxis: { title: "a", range: [0,5] },
            yaxis: { title: "b", range: [0,5] },
            zaxis: { 
                title: "SSE",
                tickvals: tickvals,
                ticktext: ticktext
            },
            camera: { eye: { x: 0, y: 0, z: 2 } } // fixed top-down view
        }
    });
}




function formatEquation(a, b) {
    if (chosen === "A*B^x") {
        return `y = ${a.toFixed(3)} \\cdot (${b.toFixed(3)})^x`;
    } else if (chosen === "A*x^B") {
        return `y = ${a.toFixed(3)} \\cdot x^{${b.toFixed(3)}}`;
    } else { // A*ln(x)+B
        return `y = ${a.toFixed(3)} \\cdot \\ln(x) + ${b.toFixed(3)}`;
    }
}

function computeR2(a, b) {
    const yPred = dataset.map(p => g(a, b, p.x));
    const yMean = dataset.reduce((sum, p) => sum + p.y, 0) / dataset.length;

    let ssRes = 0, ssTot = 0;
    dataset.forEach((p, i) => {
        ssRes += Math.pow(p.y - yPred[i], 2);
        ssTot += Math.pow(p.y - yMean, 2);
    });

    return 1 - (ssRes / ssTot);
}

function plot2DCurrentCurve() {
    const yVals = xLine.map(x => g(gdPoint.a, gdPoint.b, x));
    const r2 = computeR2(gdPoint.a, gdPoint.b);
    const eqn = formatEquation(gdPoint.a, gdPoint.b);

    // Update the MathJax equation div
    const eqDiv = document.getElementById("equationDisplay");
    eqDiv.innerHTML = `\\(${eqn},\\; R^2 = ${r2.toFixed(4)}\\)`;
    MathJax.typesetPromise();

    // Update the 2D plot
    Plotly.react("function2D", [
        {
            type: "scatter",
            mode: "markers",
            x: dataset.map(p => p.x),
            y: dataset.map(p => p.y),
            marker: { color: "black", size: 8 }
        },
        {
            type: "scatter",
            mode: "lines",
            x: xLine,
            y: yVals,
            line: { color: "red" }
        }
    ], layout2D);
}



// --- Step button ---
let stepCount = 0;  // track number of steps

document.getElementById("stepBtn").onclick = () => {
    // Compute gradient at current point
    let dSda = 0, dSdb = 0;
    dataset.forEach(p => {
        const fx = g(gdPoint.a, gdPoint.b, p.x);
        dSda += 2 * (fx - p.y) * dfda(gdPoint.a, gdPoint.b, p.x);
        dSdb += 2 * (fx - p.y) * dfdb(gdPoint.a, gdPoint.b, p.x);
    });

    // Normalize gradient (unit direction)
    const norm = Math.sqrt(dSda * dSda + dSdb * dSdb);
    if (norm > 0) {
        const unitU = -dSda / norm;  // steepest descent
        const unitV = -dSdb / norm;

        // Step size decays as (0.25 * (0.9^n))
        const stepSize = 0.3 * Math.pow(0.95, stepCount);

        // Update point
        gdPoint.a += stepSize * unitU;
        gdPoint.b += stepSize * unitV;
    }
    

    stepCount++;

    // Update plots
    trailX.push(gdPoint.a);
    trailY.push(gdPoint.b);
    trailZ.push(Math.log10(computeSSE(gdPoint.a, gdPoint.b)+1e-6));
    plotGDPoint();
    plot2DCurrentCurve();
    plotGradientField();
};
document.getElementById("step40Btn").onclick = () => {
    let stepsTaken = 0;
    const maxSteps = 40;

    const interval = setInterval(() => {
        // Compute gradient at current point
        let dSda = 0, dSdb = 0;
        dataset.forEach(p => {
            const fx = g(gdPoint.a, gdPoint.b, p.x);
            dSda += 2 * (fx - p.y) * dfda(gdPoint.a, gdPoint.b, p.x);
            dSdb += 2 * (fx - p.y) * dfdb(gdPoint.a, gdPoint.b, p.x);
        });

        // Normalize gradient
        const norm = Math.sqrt(dSda * dSda + dSdb * dSdb);
        if (norm > 0) {
            const unitU = -dSda / norm;
            const unitV = -dSdb / norm;

            // Step size decays as (0.25 * (0.9^n))
            const stepSize = 0.3 * Math.pow(0.95, stepCount);

            gdPoint.a += stepSize * unitU;
            gdPoint.b += stepSize * unitV;
        }

        stepCount++;
        trailX.push(gdPoint.a);
        trailY.push(gdPoint.b);
        trailZ.push(Math.log10(computeSSE(gdPoint.a, gdPoint.b)+1e-6));

        // Update plots live
        plotGDPoint();
        plot2DCurrentCurve();
        plotGradientField();

        stepsTaken++;
        if (stepsTaken >= maxSteps) {
            clearInterval(interval); // stop after 40
        }
    }, 100); // delay in ms per step (0.1s)
};
 document.getElementById("randomBtn").onclick = () => {
    // 1️⃣ Regenerate dataset points
    generatePoints();
    updateTable();

    // 2️⃣ Reset GD point and trail
    gdPoint = { a: Math.random() * 4 + 0.5, b: Math.random() * 4 + 0.5 };
    trailX = [gdPoint.a];
    trailY = [gdPoint.b];
    trailZ = [computeSSE(gdPoint.a, gdPoint.b)];
    stepCount = 0;

    // 3️⃣ Update plots
    plotSSE();            // regenerate 3D surface
    plotGradientField();  // regenerate vector field
    plotGDPoint();        // plot GD point on surface
    plot2DCurrentCurve(); // plot 2D curve with new points
};
 


// --- Initial plots ---
plotSSE();
plotGradientField();
plotGDPoint();
plot2DCurrentCurve();
</script>

</body>
</html>
