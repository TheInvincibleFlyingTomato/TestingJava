<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Regression SSE Surface + Gradient Field</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
<style>
body {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 20px;
  height: 100vh;
  margin: 0;
  padding: 20px;
  box-sizing: border-box;
}
.plot { width: 100%; height: 100%; }
#functionWrapper { display: flex; flex-direction: row; align-items: stretch; width: 100%; height: 100%; }
#leftSide { flex: 3; display: flex; flex-direction: column; }
#function2D { flex: 1; width: 100%; }
#controls { margin-top: 10px; }
#rightSide { flex: 1; display: flex; flex-direction: column; margin-left: 15px; }
button { margin: 5px 0; padding: 6px 12px; border-radius: 8px; border: none; background: #0077cc; color: white; cursor: pointer; }
button:hover { background: #005fa3; }
#tableWrapper { flex: 1; overflow-y: auto; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; }
table { border-collapse: collapse; width: 100%; }
th, td { border: 1px solid #ddd; padding: 6px 10px; text-align: center; }
th { background: #f0f0f0; position: sticky; top: 0; }
</style>
</head>
<body>

<div id="surfacePlot" class="plot"></div>
<div id="gradVectorField" class="plot"></div>

<div id="functionWrapper">
  <div id="leftSide">
    <div id="function2D"></div>
    <div id="controls">
      <button id="resetBtn">Reset Points</button>
      <button id="randomBtn">Generate 10 Random Points</button>
    </div>
  </div>
  <div id="rightSide">
    <div id="tableWrapper">
      <table id="pointsTable">
        <thead>
          <tr><th>#</th><th>x</th><th>y</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<script>
  // --- 1. Choose function type ---
  const forms = ["A*B^x","A*x^B","A*log(x)+B"];
  const chosen = forms[Math.floor(Math.random()*forms.length)];
  const A0 = (Math.random()*3+1).toFixed(2);
  const B0 = (Math.random()*3+1).toFixed(2);

  let g, dfda, dfdb;
  if(chosen==="A*B^x"){
    g=(a,b,x)=>a*Math.pow(b,x);
    dfda=(a,b,x)=>Math.pow(b,x);
    dfdb=(a,b,x)=>a*x*Math.pow(b,x-1);
  } else if(chosen==="A*x^B"){
    g=(a,b,x)=>a*Math.pow(x,b);
    dfda=(a,b,x)=>Math.pow(x,b);
    dfdb=(a,b,x)=>a*Math.pow(x,b)*Math.log(x);
  } else {
    g=(a,b,x)=>a*Math.log(x)+b;
    dfda=(a,b,x)=>Math.log(x);
    dfdb=(a,b,x)=>1;
  }

  // --- 2. Generate sample points ---
  const xStart = chosen.includes("log(x)")?1:0;
  const xEnd = 10;
  let dataset=[];
  const nPoints=10;
  const scale=0.05;
  const minError=0.1;

  function generatePoints(){
    dataset=[];
    for(let i=0;i<nPoints;i++){
      const x = Math.random()*(xEnd-xStart)+xStart;
      const trueY = g(parseFloat(A0),parseFloat(B0),x);
      const errMag = Math.max(scale*Math.abs(trueY),minError);
      const y = trueY + (Math.random()-0.5)*2*errMag;
      dataset.push({x,y});
    }
  }
  generatePoints();

  // --- 3. 2D plot of points (curve hidden) ---
  const xLine=[];
  for(let x=xStart;x<=xEnd;x+=0.1) xLine.push(xLine.push(x));
  const yLine = xLine.map(x=>g(parseFloat(A0),parseFloat(B0),x));

  const funcTrace={type:"scatter",mode:"lines",x:xLine,y:yLine,line:{color:"red"},name:"",visible:false};
  const pointsTrace={type:"scatter",mode:"markers",x:dataset.map(p=>p.x),y:dataset.map(p=>p.y),marker:{color:"black",size:8},name:"Sample Points"};

  const layout2D={title:"",dragmode:false,
                  xaxis:{range:[xStart,xEnd]},
                  yaxis:{range:[Math.min(...dataset.map(p=>p.y))-1,Math.max(...dataset.map(p=>p.y))+1]}};

  Plotly.newPlot("function2D",[funcTrace,pointsTrace],layout2D);

  function updateTable(){
    const tbody=document.querySelector("#pointsTable tbody");
    tbody.innerHTML="";
    dataset.forEach((p,i)=>{
      const row=document.createElement("tr");
      row.innerHTML=`<td>${i+1}</td><td>${p.x.toFixed(3)}</td><td>${p.y.toFixed(3)}</td>`;
      tbody.appendChild(row);
    });
  }
  updateTable();

  // --- 4. SSE surface ---
  const aMin=0.5,aMax=5,aStep=0.2;
  const bMin=0.5,bMax=5,bStep=0.2;
  const aVals=math.range(aMin,aMax,aStep).toArray();
  const bVals=math.range(bMin,bMax,bStep).toArray();

  function plotSSE(){
    let zValues=[];
    for(let i=0;i<aVals.length;i++){
      const row=[];
      for(let j=0;j<bVals.length;j++){
        const a=aVals[i], b=bVals[j];
        let sse=0;
        dataset.forEach(p=>{
          const fx=g(a,b,p.x);
          sse += Math.pow(fx-p.y,2);
        });
        row.push(sse);
      }
      zValues.push(row);
    }
    Plotly.newPlot("surfacePlot",[{
      type:"surface",x:aVals,y:bVals,z:zValues,colorscale:"Viridis",opacity:0.9,name:"SSE Surface"
    }],{title:`SSE Surface for ${chosen}`,scene:{xaxis:{title:"a"},yaxis:{title:"b"},zaxis:{title:"SSE"}}});
  }

  // --- 5. Gradient vector field ---
  function plotGradientField() {
    let gradX=[], mags=[];

    // Compute gradients
    for(let i=0;i<aVals.length;i++){
      for(let j=0;j<bVals.length;j++){
        const a=aVals[i], b=bVals[j];
        let dSda=0, dSdb=0;
        dataset.forEach(p=>{
          const fx=g(a,b,p.x);
          dSda += 2*(fx-p.y)*dfda(a,b,p.x);
          dSdb += 2*(fx-p.y)*dfdb(a,b,p.x);
        });
        const mag = Math.sqrt(dSda*dSda + dSdb*dSdb);
        gradX.push({a,b,u:dSda,v:dSdb,mag});
        mags.push(mag);
      }
    }

    mags.sort((a,b)=>a-b);
    const minMag = mags[0];
    const maxMag = mags[Math.floor(0.9*mags.length)] || mags[mags.length-1];

    // Vector scale and arrowhead size
    let scale=0.35;
    if(Math.max(...mags)>50) scale=0.18;
    else if(Math.max(...mags)<5) scale=0.4;
    const headSize=0.1;

    const arrows={type:"scatter",mode:"lines",x:[],y:[],line:{width:2,color:""}};

    gradX.forEach(v=>{
      const norm = Math.sqrt(v.u*v.u + v.v*v.v);
      if(norm===0) return;

      const u=-scale*v.u/norm;
      const w=-scale*v.v/norm;

      let t=(v.mag-minMag)/(maxMag-minMag+1e-6);
      t=Math.min(Math.max(t,0),1);
      t=Math.pow(t,0.7);
      const r=Math.floor(255*t), g=0, b=Math.floor(255*(1-t));
      const color=`rgb(${r},${g},${b})`;

      // Main line
      arrows.x.push(v.a, v.a+u, null);
      arrows.y.push(v.b, v.b+w, null);
      arrows.line.color=color;

      // Arrowheads ±45°
      const angle=Math.atan2(w,u);
      const leftAngle=angle+Math.PI/4;
      const rightAngle=angle-Math.PI/4;
      const leftX=v.a+u-headSize*Math.cos(leftAngle);
      const leftY=v.b+w-headSize*Math.sin(leftAngle);
      const rightX=v.a+u-headSize*Math.cos(rightAngle);
      const rightY=v.b+w-headSize*Math.sin(rightAngle);

      arrows.x.push(v.a+u,leftX,null);
      arrows.y.push(v.b+w,leftY,null);
      arrows.line.color=color;

      arrows.x.push(v.a+u,rightX,null);
      arrows.y.push(v.b+w,rightY,null);
      arrows.line.color=color;
    });

    Plotly.newPlot("gradVectorField",[arrows],{
      title:"Gradient Vector Field of SSE",
      xaxis:{title:"a",range:[0,5],scaleanchor:"y"},
      yaxis:{title:"b",range:[0,5],scaleanchor:"x"},
      showlegend:false
    });
  }

  // --- 6. Initial plot ---
  plotSSE();
  plotGradientField();

  // --- 7. Button handlers ---
  document.getElementById("resetBtn").onclick=()=>{
    generatePoints();
    pointsTrace.x = dataset.map(p=>p.x);
    pointsTrace.y = dataset.map(p=>p.y);
    layout2D.yaxis.range=[Math.min(...dataset.map(p=>p.y))-1,Math.max(...dataset.map(p=>p.y))+1];
    Plotly.react("function2D",[funcTrace,pointsTrace],layout2D);
    updateTable();
    plotSSE();
    plotGradientField();
  };

  document.getElementById("randomBtn").onclick=()=>{
    generatePoints();
    pointsTrace.x = dataset.map(p=>p.x);
    pointsTrace.y = dataset.map(p=>p.y);
    layout2D.yaxis.range=[Math.min(...dataset.map(p=>p.y))-1,Math.max(...dataset.map(p=>p.y))+1];
    Plotly.react("function2D",[funcTrace,pointsTrace],layout2D);
    updateTable();
    plotSSE();
    plotGradientField();
  };
</script>
</body>
</html>
